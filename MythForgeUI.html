async function sendMessage(){
    const text = userInput.value.trim();
    if(text === '' || state.isGenerating || !state.currentChatId) return;

    // clear & resize input
    userInput.value = '';
    autoResize();

    // disable both send buttons and swap UI to “stopping” state
    sendButton.disabled = true;
    sendOnlyButton.disabled = true;
    sendButton.style.display = 'none';
    sendOnlyButton.style.display = 'none';
    stopButton.style.display = 'inline';

    // track index for editing/removal
    const userIdx = state.nextIndex;
    appendMessageToUI('user', text, userIdx);

    addTyping();
    state.isGenerating = true;
    abortController = new AbortController();

    try {
        const response = await fetch('/chat/stream', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({
                chat_id: state.currentChatId,
                message: text,
                global_prompt: gpSelect.value
            }),
            signal: abortController.signal
        });
        if(!response.ok) throw new Error(`Server returned ${response.status}`);

        removeTyping();
        // reserve next slot for the bot
        appendMessageToUI('assistant', '', userIdx+1);
        const aiElement = chatContainer.lastChild.querySelector('.message-content');

        const reader = response.body.getReader();
        const decoder = new TextDecoder('utf-8');
        let buffer = '', done = false, firstLine = true, accumulated = '';

        while(!done){
            const {value, done: doneReading} = await reader.read();
            done = doneReading;
            if(value){
                buffer += decoder.decode(value, {stream:true});
                while(buffer.includes('\n')){
                    const idx = buffer.indexOf('\n');
                    const chunk = buffer.slice(0, idx);
                    buffer = buffer.slice(idx+1);

                    if(firstLine){
                        firstLine = false;
                        try {
                            const meta = JSON.parse(chunk);
                            systemPrompt.textContent = meta.prompt || '';
                            systemToggle.style.display = meta.prompt ? 'block' : 'none';
                        } catch{}
                    } else {
                        accumulated += chunk;
                        aiElement.innerHTML = accumulated.replace(/\n/g,'<br>');
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                    }
                }
            }
        }
    } catch(err) {
        if(err.name !== 'AbortError'){
            console.error('Streaming fetch failed:', err);
            removeTyping();
            appendMessageToUI('assistant', '[Error generating response]', userIdx+1);
        }
    } finally {
        state.isGenerating = false;
        // restore buttons
        sendButton.disabled = userInput.value.trim() === '';
        sendOnlyButton.disabled = sendButton.disabled;
        stopButton.style.display = 'none';
        sendButton.style.display = 'inline';
        sendOnlyButton.style.display = 'inline';
        userInput.focus();
    }
}

async function sendMessageNoGen(){
    const text = userInput.value.trim();
    if(text === '' || state.isGenerating || !state.currentChatId) return;

    userInput.value = '';
    autoResize();
    sendButton.disabled = true;
    sendOnlyButton.disabled = true;
    appendMessageToUI('user', text);

    try {
        await fetch('/message', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({
                chat_id: state.currentChatId,
                message: text,
                global_prompt: gpSelect.value
            })
        });
    } catch(err){
        console.error('Send only failed:', err);
    } finally {
        sendButton.disabled = userInput.value.trim() === '' || state.isGenerating;
        sendOnlyButton.disabled = sendButton.disabled;
        userInput.focus();
    }
}
