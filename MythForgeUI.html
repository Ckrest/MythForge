<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Myth Forge</title>
  <style>
    html, body {
      height: 100%; margin: 0; padding: 0;
      font-family: monospace;
      background: #111; color: #ddd;
      -webkit-user-select: none;
      user-select: none;
      display: flex;
      flex-direction: column;
    }
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 1em;
      display: flex;
      flex-direction: column-reverse;
    }
    .msg { margin-bottom: 1em; }
    .user { color: #6cf; }
    .bot  { color: #fc6; }
    #top-controls, #bottom-controls {
      display: flex;
      gap: 0.5em;
      padding: 0.5em;
      background: #222;
      align-items: center;
    }
    #input { flex: 1; }
    #system-toggle {
      background: #444;
      color: #ccc;
      padding: 0.25em 0.5em;
      cursor: pointer;
    }
    #system-container {
      display: none;
      padding: 0.5em;
      background: #1a1a1a;
    }
    select, input[type="text"], button, textarea {
      background: #333;
      color: #ddd;
      border: 1px solid #555;
      padding: 0.5em;
    }
    #loading-spinner {
      position: fixed;
      bottom: 3.5em;
      right: 0.8em;
      width: 16px;
      height: 16px;
      border: 3px solid #ccc;
      border-top: 3px solid #6cf;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
      z-index: 10;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="top-controls">
    <select id="chatSelect"></select>

    <select id="globalPromptSelect">
      <option value="">(no global prompt)</option>
    </select>
    <button onclick="openPromptEditor()">✏️ Edit Prompts</button>
    <button onclick="addNewPrompt()">➕ Add Prompt</button>

    <button onclick="startNewChat()">New Chat</button>
    <button onclick="deleteChat()">Delete</button>
    <span id="system-toggle" onclick="toggleSystem()">⚙️ Last Prompt</span>
  </div>

  <div id="system-container">
    <textarea id="system-prompt" rows="3" placeholder="Last raw prompt (for debugging)"></textarea>
  </div>

  <div id="main">
    <div id="chat-container"></div>
    <div id="bottom-controls">
      <input type="text" id="input" placeholder="Type a message..." onkeydown="if(event.key==='Enter'){send()}"/>
      <button onclick="send()">Send</button>
    </div>
  </div>

  <div id="loading-spinner"></div>

  <script>
    let chatId = "default";
    let chats  = {};
    const chatSelect       = document.getElementById("chatSelect");
    const chatContainer    = document.getElementById("chat-container");
    const input            = document.getElementById("input");
    const systemPrompt     = document.getElementById("system-prompt");
    const loadingSpinner   = document.getElementById("loading-spinner");
    const systemContainer  = document.getElementById("system-container");

    function toggleSystem() {
      systemContainer.style.display =
        systemContainer.style.display === "none" ? "block" : "none";
    }

    function appendMessage(role, content) {
      const div = document.createElement("div");
      div.className = `msg ${role}`;
      div.textContent = `${role === 'user' ? 'You' : 'Bot'}: ${content}`;
      chatContainer.prepend(div);
      return div;
    }

    function updateChatSelect() {
      chatSelect.innerHTML = Object.keys(chats)
        .map(id => `<option value="${id}">${id}</option>`)
        .join("");
      chatSelect.value = chatId;
    }

    function startNewChat() {
      const name = prompt("Enter new chat name:");
      if (name === null) return;
      const trimmed = name.trim();
      if (!trimmed) {
        alert("Name cannot be empty. Try again.");
        return;
      }
      if (chats.hasOwnProperty(trimmed)) {
        alert("That name’s already taken. Pick something else.");
        return;
      }
      chatId = trimmed;
      chats[chatId] = [];
      updateChatSelect();
      chatContainer.innerHTML = "";
      systemPrompt.value = "";
    }

    function deleteChat() {
      if (!chatId || !chats[chatId]) {
        alert("Nothing to delete.");
        return;
      }
      if (!confirm("Are you sure you want to delete this chat?")) return;

      fetch(`http://localhost:8000/chat/${encodeURIComponent(chatId)}`, {
        method: "DELETE"
      })
      .then(res => {
        if (!res.ok) {
          if (res.status === 404) throw new Error("Chat not found on server.");
          else throw new Error("Unknown server error.");
        }
        delete chats[chatId];
        if (chats["default"]) {
          chatId = "default";
        } else {
          const keys = Object.keys(chats);
          chatId = keys.length ? keys[0] : "";
        }
        updateChatSelect();
        chatContainer.innerHTML = "";
        systemPrompt.value = "";
      })
      .catch(err => {
        console.error("Failed to delete chat:", err);
        alert("Error deleting chat: " + err.message);
      });
    }

    async function send() {
      const text = input.value.trim();
      if (!text) return;
      input.value = "";

      appendMessage("user", text);
      const botBubble = appendMessage("bot", "");
      loadingSpinner.style.display = "block";

      const gpSelect       = document.getElementById("globalPromptSelect");
      const selectedPrompt = gpSelect.value;

      try {
        const response = await fetch(`http://localhost:8000/chat/stream`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            chat_id: chatId,
            message: text,
            global_prompt: selectedPrompt
          })
        });

        if (!response.ok) {
          throw new Error(`Server returned ${response.status}`);
        }

        // 1) Read the first line as JSON containing {"prompt": "..."}
        const reader  = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let done = false;
        let buffer = "";

        // Read until we see a newline:
        while (!done) {
          const { value, done: doneReading } = await reader.read();
          done = doneReading;
          if (value) {
            buffer += decoder.decode(value, { stream: true });
            const newlineIndex = buffer.indexOf("\n");
            if (newlineIndex !== -1) {
              // We found the end of the first line
              const firstLine = buffer.slice(0, newlineIndex);
              buffer = buffer.slice(newlineIndex + 1);
              try {
                const meta = JSON.parse(firstLine);
                systemPrompt.value = meta.prompt || "";
              } catch {
                systemPrompt.value = "";
              }
              break;
            }
          }
        }

        // 2) Whatever remains in buffer is part of the first token‐chunk (if any)
        let accumulatedText = buffer;
        botBubble.textContent = "Bot: " + accumulatedText;

        // 3) Continue streaming the rest of the chunks
        while (!done) {
          const { value, done: doneReading } = await reader.read();
          done = doneReading;
          if (value) {
            const chunk = decoder.decode(value, { stream: true });
            accumulatedText += chunk;
            botBubble.textContent = "Bot: " + accumulatedText;
          }
        }

        loadingSpinner.style.display = "none";
      }
      catch (err) {
        console.error("Streaming fetch failed:", err);
        botBubble.textContent = "Bot: [Error generating response]";
        loadingSpinner.style.display = "none";
      }
    }

    async function fetchChatList() {
      try {
        const res = await fetch(`http://localhost:8000/chats`);
        const json = await res.json();
        json.chats.forEach(id => {
          chats[id] = [];
        });
        if (!chats["default"] && json.chats.length > 0) {
          chatId = json.chats[0];
        } else if (chats["default"]) {
          chatId = "default";
        }
        updateChatSelect();
      } catch (e) {
        console.error("Could not fetch chat list:", e);
      }
    }

    async function loadHistory(id) {
      chatContainer.innerHTML = "";
      systemPrompt.value = "";
      if (!id) return;
      try {
        const res = await fetch(`http://localhost:8000/history/${encodeURIComponent(id)}`);
        if (!res.ok) return;
        const messages = await res.json();
        messages.forEach(msg => appendMessage(msg.role, msg.content));
      } catch (e) {
        console.error(`Failed to load history for ${id}:`, e);
      }
    }

    chatSelect.addEventListener("change", () => {
      chatId = chatSelect.value;
      loadHistory(chatId);
    });

    async function refreshGlobalPromptList() {
      try {
        const res  = await fetch(`http://localhost:8000/prompts`);
        const json = await res.json();
        const select = document.getElementById("globalPromptSelect");
        select.innerHTML = `<option value="">(no global prompt)</option>`;
        json.prompts.forEach(p => {
          const opt = document.createElement("option");
          opt.value = p.name;
          opt.textContent = p.name;
          select.append(opt);
        });
      } catch (e) {
        console.error("Failed to load global prompts:", e);
      }
    }

    async function addNewPrompt() {
      const name = prompt("Enter a unique prompt name (no spaces):");
      if (name === null) return;
      const trimmed = name.trim();
      if (!trimmed) return alert("Name cannot be empty.");

      const content = prompt(`Enter the text for "${trimmed}":`);
      if (content === null) return;
      const contTrim = content.trim();
      if (!contTrim) return alert("Prompt content cannot be empty.");

      try {
        const res = await fetch(`http://localhost:8000/prompts`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: trimmed, content: contTrim })
        });
        if (!res.ok) {
          const err = await res.json();
          return alert("Error: " + err.detail);
        }
        await refreshGlobalPromptList();
        alert(`Prompt "${trimmed}" created.`);
      } catch (e) {
        console.error("Failed to create prompt:", e);
        alert("Failed to create prompt: " + e.message);
      }
    }

    async function openPromptEditor() {
      const select = document.getElementById("globalPromptSelect");
      const name   = select.value;
      if (!name) return alert("Select a prompt from the dropdown first.");

      try {
        const res  = await fetch(`http://localhost:8000/prompts`);
        const json = await res.json();
        const promptObj = json.prompts.find(p => p.name === name);
        if (!promptObj) return alert("Prompt not found.");

        const newContent = prompt(`Edit content for "${name}":`, promptObj.content);
        if (newContent === null) return;
        const contTrim = newContent.trim();
        if (!contTrim) return alert("Prompt content cannot be empty.");

        const updateRes = await fetch(`http://localhost:8000/prompts/${encodeURIComponent(name)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name, content: contTrim })
        });
        if (!updateRes.ok) {
          const err = await updateRes.json();
          return alert("Error: " + err.detail);
        }
        await refreshGlobalPromptList();
        alert(`Prompt "${name}" updated.`);
      } catch (e) {
        console.error("Failed to update prompt:", e);
        alert("Failed to update prompt: " + e.message);
      }
    }

    (async function init() {
      await fetchChatList();
      if (chatId) await loadHistory(chatId);
      await refreshGlobalPromptList();
    })();

    input.addEventListener("focus", () => {
      setTimeout(() => { window.scrollTo(0, 0); }, 100);
    });
    input.addEventListener("blur", () => {
      setTimeout(() => { window.scrollTo(0, 0); }, 100);
    });
  </script>
</body>
</html>
